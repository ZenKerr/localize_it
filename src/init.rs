/// Initializes the localization system.
///
/// This macro must be invoked **once** at the module level. It generates:
/// * `enum Locale` — the list of supported languages, which provides:
///   * The enum derives the following traits:
///     * `Debug`
///     * `Default` — the default value is the first variant passed to this macro
///     * `Clone`
///     * `Copy`
///     * `PartialEq`
///     * `Eq`
///     * `PartialOrd`
///     * `Ord`
///     * `Hash`
///   * `const COUNT: usize` — number of languages
///   * Conversions between `Locale` and `usize`:
///     * `fn from_usize(usize) -> Option<Locale>`
///     * `fn from_usize_or_default(usize) -> Locale`
///     * `impl From<Locale> for usize`
///     * `impl TryFrom<usize> for Locale`
/// * `type Expression` — a type for localized expressions
///
/// If you want to use the built-in locale storage, you can use
/// [`init_locale_with_storage!`](crate::init_locale_with_storage!).
///
/// # Examples
///
/// ```rust
/// init_locale!(EN, RU);
/// ```
#[macro_export]
macro_rules! init_locale {
    ($($variant: ident),+ $(,)?) => {
        #[derive(Debug, Default, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
        #[repr(usize)]
        pub enum Locale {
            #[default]
            $($variant),+
        }

        impl Locale {
            pub const COUNT: usize = [$(stringify!($variant)),+].len();

            pub fn from_usize(value: usize) -> Option<Self> {
                match value {
                    $(
                        _ if value == usize::from(Locale::$variant) => Some(Locale::$variant),
                    )+
                    _ => None,
                }
            }

            pub fn from_usize_or_default(value: usize) -> Self {
                Locale::from_usize(value).unwrap_or_default()
            }
        }

        impl From<Locale> for usize {
            #[inline]
            fn from(locale: Locale) -> Self {
                locale as usize
            }
        }

        impl TryFrom<usize> for Locale {
            type Error = &'static str;

            fn try_from(value: usize) -> Result<Self, Self::Error> {
                Locale::from_usize(value).ok_or("Invalid value for Locale")
            }
        }

        pub type Expression = [&'static str; Locale::COUNT];
    };
}

/// Initializes the localization system and the mechanism for storing the current locale.
///
/// This macro must be invoked **once** at the module level. It generates:
/// * All items generated by [`init_locale!`](crate::init_locale!)
/// * `get_locale()` and `set_locale()` — functions for managing the global current locale state
///
/// If you don't need the built-in locale storage, you can use
/// [`init_locale!`](crate::init_locale!).
///
/// # Examples
///
/// ```rust
/// init_locale_with_storage!(EN, RU);
/// ```
#[macro_export]
macro_rules! init_locale_with_storage {
    ($($variant: ident),+ $(,)?) => {
        localize_it::init_locale!($($variant),+);

        mod storage {
            use super::Locale;
            use core::sync::atomic::{AtomicUsize, Ordering};

            static CURRENT_LOCALE: AtomicUsize = AtomicUsize::new(0);

            #[inline]
            pub fn get_locale() -> Locale {
                Locale::from_usize_or_default(CURRENT_LOCALE.load(Ordering::Relaxed))
            }

            #[inline]
            pub fn set_locale(locale: Locale) {
                CURRENT_LOCALE.store(usize::from(locale), Ordering::Relaxed)
            }
        }

        pub use storage::{get_locale, set_locale};
    }
}
